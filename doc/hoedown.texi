\input texinfo.tex
@c %**start of header
@setfilename hoedown.info
@settitle Hoedown
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Hoedown

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Hoedown

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           hoedown

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2008, 2011, 2014, 2015

@c ------------------------------------------------------------

@set ORIGINAL_URL               @url{http:/@//@/github.com/@/hoedown/@/@value{PACKAGE_NICKNAME}}
@set GITHUB_URL                 @url{http:/@//@/github.com/@/marcomaggi/@/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https:/@//@/bitbucket.org/@/marcomaggi/@/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https:/@//@/bitbucket.org/@/marcomaggi/@/@value{PACKAGE_NICKNAME}/@/downloads}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C
language library implementing a template library.  This distribution is
an repackaging of the original @value{PACKAGE} package, using the @gnu{}
Autotools.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}).

The latest release of the repackaged @value{PACKAGE} can be downloaded
from:

@center @value{DOWNLOAD_URL}

@noindent
the original package development takes place at:

@center @value{ORIGINAL_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} 2008, Natacha Porte@*
Copyright @copyright{} 2011, Vicent Marti@*
Copyright @copyright{} 2014, Xavier Mendez, Devin Torres and the Hoedown authors

@quotation
Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED ``AS IS'' AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE
FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* hoedown: (hoedown).       Hoedown a Markdown parser library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* buffers::                     Data buffers.

Appendices

* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C
language library implementing a Markdown parser.  This distribution is
an repackaging of the original @value{PACKAGE} package, using the @gnu{}
Autotools.

@value{PACKAGE} installs multiple header files under the directory
@code{$(prefix)/hoedown/}.  All the function names in the @api{} are
prefixed with @code{hoedown_}; all the constant names are prefixed with
@code{HOEDOWN_}; all the type names are prefixed with @code{hoedown_}.

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when
searching for the installed library with the @gnu{} Autotools, we can:

@itemize
@item
Install the file @file{pkg.m4} from @file{/usr/share/aclocal} into the
source tree of the package, for example under @file{meta/autoconf/}.

@item
Include @file{pkg.m4} in the template by adding the following line to
@file{acinclude.m4}:

@example
m4_include(meta/autoconf/pkg.m4)
@end example

@item
Just add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([HOEDOWN],[hoedown >= 3.0.3])
@end example

@noindent
which will set the variables @code{HOEDOWN_LIBS} and
@code{HOEDOWN_CFLAGS}.
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([hoedown],[hoedown_version],,
  [AC_MSG_FAILURE([test for Hoedown library failed])])
AC_CHECK_HEADERS([hoedown/version.h],,
  [AC_MSG_FAILURE([test for Hoedown header failed])])
@end example

@c page
@node version
@chapter Version functions


@ignore
The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.
@end ignore

The definitions of the buffers @api{} are in the header file
@file{hoedown/version.h}.


@deftypefun void hoedown_version (int * @var{major}, int * @var{minor}, int * @var{revision})
Retrieve version numbers, storing them in the referenced @code{int}
locations.
@end deftypefun


@defvr {Preprocessor Constant} HOEDOWN_VERSION
A string representing the full version number.
@end defvr


@defvr {Preprocessor Constant} HOEDOWN_MAJOR
@defvrx {Preprocessor Constant} HOEDOWN_MINOR
@defvrx {Preprocessor Constant} HOEDOWN_REVISION
Integers representing version number components.
@end defvr

@c page
@node buffers
@chapter Data buffers


@menu
* buffers memory::              Memory handling in data buffers.
* buffers struct::              Data buffer structure.
* buffers append::              Appending data to buffers.
* buffers set::                 Setting data in buffers.
* buffers compar::              Comparing data in buffers.
* buffers misc::                Miscellaneous functions.
@end menu

@c page
@node buffers memory
@section Memory handling in data buffers


The definitions of the buffers @api{} are in the header file
@file{hoedown/buffer.h}.


@deftp {Function Pointer Typedef} hoedown_realloc_callback
Type definition for function pointers implementing a memory reallocation
callback.  It is meant to be used as follows:

@example
void *
realloc_callback (void * ptr, size_t len)
@{
  ...
@}

hoedown_realloc_callback R = realloc_callback;
@end example

This function pointer type is meant to match the one of the C Language
Standard function @cfunc{realloc}.
@end deftp


@deftp {Function Pointer Typedef} hoedown_free_callback
Type definition for function pointers implementing a memory release
callback.  It is meant to be used as follows:

@example
void
free_callback (void * ptr)
@{
  ...
@}

hoedown_free_callback F = free_callback;
@end example

This function pointer type is meant to match the one of the C Language
Standard function @cfunc{free}.
@end deftp


@deftypefun {void *} hoedown_malloc (size_t @var{size})
Wrapper for the C Language Standard @cfunc{malloc}.  If memory
allocation fails: abort the process by calling @cfunc{abort}.
@end deftypefun


@deftypefun {void *} hoedown_calloc (size_t @var{nmemb}, size_t @var{size})
Wrapper for the C Language Standard @cfunc{calloc}.  If memory
allocation fails: abort the process by calling @cfunc{abort}.
@end deftypefun


@deftypefun {void *} hoedown_realloc (void * @var{ptr}, size_t @var{size})
Wrapper for the C Language Standard @cfunc{realloc}.  If memory
reallocation fails: abort the process by calling @cfunc{abort}.
@end deftypefun


@c page
@node buffers struct
@section Data buffer structure


The definitions of the buffers @api{} are in the header file
@file{hoedown/buffer.h}.


@deftp {Struct Typedef} hoedown_buffer
Type of structures representing data buffers.  Instances of this type
must be initialised by @cfunc{hoedown_buffer_init} and finalised by
@cfunc{hoedown_buffer_uninit}.

Basic allocation, initialisation and finalisation can be performed as:

@example
hoedown_buffer          B;

hoedown_buffer_init(&B, 1, realloc, free, free);
hoedown_buffer_uninit(&B);
@end example

@noindent
or as:

@example
hoedown_buffer *        B;

B = hoedown_buffer_new(1);
hoedown_buffer_free(B);
@end example
@end deftp


@deftypefun void hoedown_buffer_init (hoedown_buffer * @var{buffer}, size_t @var{reallocation-unit}, hoedown_realloc_callback @var{data_realloc}, hoedown_free_callback @var{data_free}, hoedown_free_callback @var{buffer_free})
Initialise a buffer with custom memory allocators.

@var{buffer} must be a pointer referencing an already allocated data
structure.  When the internal data area is reallocated to make it
bigger: @var{reallocation-unit} is the minimum increase in the area
size, measured in number of bytes.

@var{data_realloc} must reference a function used to allocate and/or
reallocate a memory block.  @var{data_free} must reference a function
used to release the data area of the buffer.  @var{buffer_free} must
reference a function used to release the @objtype{hoedown_buffer}
structure itself.
@end deftypefun


@deftypefun void hoedown_buffer_uninit (hoedown_buffer * @var{buf})
Finalise the given buffer structure.  Memory allocated for the internal
data area is released using the registered @var{data_free} function.
The memory block referenced by @var{buf} is @strong{not} released.
@end deftypefun


@deftypefun {hoedown_buffer *} hoedown_buffer_new (size_t @var{reallocation-unit})
Convenience function that allocates a new @objtype{hoedown_buffer}
structure and initialises it with default memory handlers; internally it
makes use of @cfunc{hoedown_buffer_init}.  Return a pointer to the newly
allocated structure.

The structure memory block is allocated with the C Language Standard
@cfunc{malloc}.  @cfunc{hoedown_realloc} is registered as
@var{data_realloc} function.  The C Language Standard @cfunc{free} is
registered as both @var{data_free} and @var{buffer_free} function.
@end deftypefun


@deftypefun void hoedown_buffer_free (hoedown_buffer * @var{buf})
Convenience function that finalises and releases the given buffer
structure; internally it is similar to @cfunc{hoedown_buffer_uninit}.
Release both the data area memory and the structure memory using the
registered memory handlers.
@end deftypefun


@deftypefun void hoedown_buffer_reset (hoedown_buffer * @var{buf})
Reset to empty the given buffer structure.  Release the internal data
area using the registered memory handlers.
@end deftypefun


@deftypefun void hoedown_buffer_grow (hoedown_buffer * @var{buf}, size_t @var{neosz})
Increase the allocated data area size to the given value.  Memory for
the data area is allocated and reallocated with the registered memory
handlers.

@example
hoedown_buffer              B;
hoedown_buffer_init(&B, 1, realloc, free, free);
@{
  hoedown_buffer_grow(&B, 4096);
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun

@c page
@node buffers append
@section Appending data to buffers


The definitions of the buffers @api{} are in the header file
@file{hoedown/buffer.h}.


@deftypefun void hoedown_buffer_put (hoedown_buffer * @var{buf}, const uint8_t * @var{data}, size_t @var{size})
Append raw data to a buffer.  The internal data area is resized as
needed and octets referenced by @var{data} are copied into it.

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_put(&B, (const uint8_t*)str, strlen(str));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun void hoedown_buffer_puts (hoedown_buffer * @var{buf}, const char * @var{str})
Append a NUL--terminated string to a buffer.

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str);
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefn {Preprocessor Macro} void HOEDOWN_BUFPUTSL (hoedown_buffer * @var{buf}, const char * @var{str})
Optimized @cfunc{hoedown_buffer_put} of a string literal.  It is meant
to be used when @var{str} references a literal string, as in:

@example
hoedown_buffer              B;
static const char *         str  = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  HOEDOWN_BUFPUTSL(&B, "Hello ");
  HOEDOWN_BUFPUTSL(&B, "World!");
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefn


@deftypefun void hoedown_buffer_putc (hoedown_buffer * @var{buf}, uint8_t @var{c})
Append a single char to a buffer.

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  for (int i=0; i<strlen(str); ++i) @{
    hoedown_buffer_putc(&B, str[i]);
  @}
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun int hoedown_buffer_putf (hoedown_buffer * @var{buf}, FILE * @var{file})
Read from a file and append to a buffer, until EOF or error.

@example
hoedown_buffer              B;
FILE *                      M;
char                        str[32];
hoedown_buffer_init(&B, 1024, realloc, free, free);
M = fopen("file.ext", "r");
@{
  hoedown_buffer_putf(&B, M);
@}
fclose(M);
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun void hoedown_buffer_put_utf8 (hoedown_buffer * @var{buf}, unsigned int @var{codepoint})
Put a Unicode character encoded as @utf{}-8.

@example
hoedown_buffer              B;
uint32_t                    cp    = 0x10FFFF;
uint8_t                     buf[] = @{
  244, 143, 191, 191
@};
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_put_utf8(&B, cp);
  assert(0 == memcmp(buf, B.data, B.size));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun

@c page
@node buffers set
@section Setting data in buffers


The definitions of the buffers @api{} are in the header file
@file{hoedown/buffer.h}.


@deftypefun void hoedown_buffer_set (hoedown_buffer * @var{buf}, const uint8_t * @var{data}, size_t @var{size})
Replace the buffer's contents with raw data.

@example
hoedown_buffer              B;
static const char *         str1 = "Hello World!";
static const char *         str2 = "Ciao Mondo!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_put(&B, (const uint8_t*)str1, strlen(str1));
  hoedown_buffer_set(&B, (const uint8_t*)str2, strlen(str2));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun void hoedown_buffer_sets (hoedown_buffer * @var{buf}, const char * @var{str})
Replace the buffer's contents with a NUL-terminated string.

@example
hoedown_buffer              B;
static const char *         str1 = "Hello World!";
static const char *         str2 = "Ciao Mondo!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str1);
  assert(0 == memcmp(str1, B.data, B.size));
  hoedown_buffer_sets(&B, str2);
  assert(0 == memcmp(str2, B.data, B.size));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefn {Preprocessor Macro} void HOEDOWN_BUFSETSL (hoedown_buffer * @var{buf}, const char * @var{str})
Optimized @cfunc{hoedown_buffer_sets} of a string literal.  It is meant
to be used when @var{str} references a literal string, as in:

@example
hoedown_buffer              B;
static const char *         str1 = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str1);
  HOEDOWN_BUFSETSL(&B, "Ciao Mondo!");
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefn

@c page
@node buffers compar
@section Comparing data in buffers


The definitions of the buffers @api{} are in the header file
@file{hoedown/buffer.h}.


@deftypefun int hoedown_buffer_eq (const hoedown_buffer * @var{buf}, const uint8_t * @var{data}, size_t @var{size})
Compare a buffer's data with other data for equality: return true
(non--zero) if the octets are equal, return false (zero) otherwise.

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str);
  assert(0 != hoedown_buffer_eq(&B,
                (const uint8_t*)str, strlen(str)));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun int hoedown_buffer_eqs (const hoedown_buffer * @var{buf}, const char * @var{str})
Compare a buffer's data with a NUL--terminated string for equality:
return true (non--zero) if the octets are equal, return false (zero)
otherwise.

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str);
  assert(0 != hoedown_buffer_eqs(&B, str));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefn {Preprocessor Macro} int HOEDOWN_BUFEQSL (hoedown_buffer * @var{buf}, const char * @var{str})
Optimized @cfunc{hoedown_buffer_eqs} of a string literal.  It is meant
to be used when @var{str} references a literal string, as in:

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str);
  assert(0 != HOEDOWN_BUFEQSL(&B, "Hello World!"));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefn


@deftypefun int hoedown_buffer_prefix (const hoedown_buffer * @var{buf}, const char * @var{prefix})
Compare the beginning of a buffer with a string: return zero if the
octets are equal; return greater than zero if an octet in @var{buf} is
found to be greater than the octet in @var{prefix}; return less than
zero if an octet in @var{buf} is found to be less than the octet in
@var{prefix}.

@example
hoedown_buffer              B;
static const char *         str1 = "Hello World!";
static const char *         str2 = "Hello";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str1);
  assert(0 == hoedown_buffer_prefix(&B, str2));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun

@c page
@node buffers misc
@section Miscellaneous functions


The definitions of the buffers @api{} are in the header file
@file{hoedown/buffer.h}.


@deftypefun void hoedown_buffer_slurp (hoedown_buffer * @var{buf}, size_t @var{size})
Remove a given number of bytes from the head of the buffer.

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str);
  hoedown_buffer_slurp(&B, strlen("Hello "));
  assert(0 != hoedown_buffer_eqs(&B, "World!"));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun {const char *} hoedown_buffer_cstr (hoedown_buffer * @var{buf})
Mutate the internal data area so that it valid as NUL-terminated C
string.  Return a pointer to the data area.
@end deftypefun


@deftypefun void hoedown_buffer_printf (hoedown_buffer * @var{buf}, const char * @var{fmt}, ...)
Formatted printing to a buffer.

@example
hoedown_buffer              B;
static const char *         str1 = "Hello";
static const char *         str2 = "World";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_printf(&B, "%s %s!", str1, str2);
  assert(0 != hoedown_buffer_eqs(&B, "Hello World!"));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun

@c page
@node references
@appendix Bibliography and references


The latest release of the repackaged @value{PACKAGE} can be downloaded
from:

@center @value{DOWNLOAD_URL}

@noindent
the original package development takes place at:

@center @value{ORIGINAL_URL}

@noindent
development of the repackaging takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

