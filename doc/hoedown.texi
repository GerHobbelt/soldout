\input texinfo.tex
@c %**start of header
@setfilename hoedown.info
@settitle Hoedown
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Hoedown

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Hoedown

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           hoedown

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2008, 2011, 2014, 2015

@c ------------------------------------------------------------

@set ORIGINAL_URL               @url{http:/@//@/github.com/@/hoedown/@/@value{PACKAGE_NICKNAME}}
@set GITHUB_URL                 @url{http:/@//@/github.com/@/marcomaggi/@/@value{PACKAGE_NICKNAME}}
@set BITBUCKET_URL              @url{https:/@//@/bitbucket.org/@/marcomaggi/@/@value{PACKAGE_NICKNAME}}
@set DOWNLOAD_URL               @url{https:/@//@/bitbucket.org/@/marcomaggi/@/@value{PACKAGE_NICKNAME}/@/downloads}

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{VERSION} of @value{PACKAGE}, a C
language library implementing a template library.  This distribution is
an repackaging of the original @value{PACKAGE} package, using the @gnu{}
Autotools.

The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}).

The latest release of the repackaged @value{PACKAGE} can be downloaded
from:

@center @value{DOWNLOAD_URL}

@noindent
the original package development takes place at:

@center @value{ORIGINAL_URL}

@noindent
development takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@noindent
Copyright @copyright{} 2008, Natacha Porte@*
Copyright @copyright{} 2011, Vicent Marti@*
Copyright @copyright{} 2014, Xavier Mendez, Devin Torres and the Hoedown authors

@quotation
Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED ``AS IS'' AND THE AUTHOR DISCLAIMS ALL
WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE
FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* hoedown: (hoedown).       Hoedown a Markdown parser library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* buffers::                     Data buffers.
* stacks::                      Stack containers.
* escape::                      Escaping text elements.
* autolink::                    Autolink helpers.

Appendices

* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a C
language library implementing a Markdown parser.  This distribution is
an repackaging of the original @value{PACKAGE} package, using the @gnu{}
Autotools.

@value{PACKAGE} installs multiple header files under the directory
@code{$(prefix)/hoedown/}.  All the function names in the @api{} are
prefixed with @code{hoedown_}; all the constant names are prefixed with
@code{HOEDOWN_}; all the type names are prefixed with @code{hoedown_}.

@menu
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview linking
@section Linking code with the library


This package installs a data file for @command{pkg-config}, so when
searching for the installed library with the @gnu{} Autotools, we can:

@itemize
@item
Install the file @file{pkg.m4} from @file{/usr/share/aclocal} into the
source tree of the package, for example under @file{meta/autoconf/}.

@item
Include @file{pkg.m4} in the template by adding the following line to
@file{acinclude.m4}:

@example
m4_include(meta/autoconf/pkg.m4)
@end example

@item
Just add the following macro use to @file{configure.ac}:

@example
PKG_CHECK_MODULES([HOEDOWN],[hoedown >= 3.0.3])
@end example

@noindent
which will set the variables @code{HOEDOWN_LIBS} and
@code{HOEDOWN_CFLAGS}.
@end itemize

Alternatively we can use the raw @gnu{} Autoconf macros:

@example
AC_CHECK_LIB([hoedown],[hoedown_version],,
  [AC_MSG_FAILURE([test for Hoedown library failed])])
AC_CHECK_HEADERS([hoedown/version.h],,
  [AC_MSG_FAILURE([test for Hoedown header failed])])
@end example

@c page
@node version
@chapter Version functions


@ignore
The installed libraries follow version numbering as established by the
@gnu{} Autotools.  For an explanation of interface numbers as managed by
@gnu{} Libtool @xref{Libtool versioning, interface, Libtool's versioning
system, libtool, Shared library support for @gnu{}}.
@end ignore

The definitions of the buffers @api{} are in the header file
@file{hoedown/version.h}.


@deftypefun void hoedown_version (int * @var{major}, int * @var{minor}, int * @var{revision})
Retrieve version numbers, storing them in the referenced @code{int}
locations.
@end deftypefun


@defvr {Preprocessor Constant} HOEDOWN_VERSION
A string representing the full version number.
@end defvr


@defvr {Preprocessor Constant} HOEDOWN_MAJOR
@defvrx {Preprocessor Constant} HOEDOWN_MINOR
@defvrx {Preprocessor Constant} HOEDOWN_REVISION
Integers representing version number components.
@end defvr

@c page
@node buffers
@chapter Data buffers


@menu
* buffers memory::              Memory handling in data buffers.
* buffers struct::              Data buffer structure.
* buffers append::              Appending data to buffers.
* buffers set::                 Setting data in buffers.
* buffers compar::              Comparing data in buffers.
* buffers misc::                Miscellaneous functions.
@end menu

@c page
@node buffers memory
@section Memory handling in data buffers


The definitions of the buffers @api{} are in the header file
@file{hoedown/buffer.h}.


@deftp {Function Pointer Typedef} hoedown_realloc_callback
Type definition for function pointers implementing a memory reallocation
callback.  It is meant to be used as follows:

@example
void *
realloc_callback (void * ptr, size_t len)
@{
  ...
@}

hoedown_realloc_callback R = realloc_callback;
@end example

This function pointer type is meant to match the one of the C Language
Standard function @cfunc{realloc}.
@end deftp


@deftp {Function Pointer Typedef} hoedown_free_callback
Type definition for function pointers implementing a memory release
callback.  It is meant to be used as follows:

@example
void
free_callback (void * ptr)
@{
  ...
@}

hoedown_free_callback F = free_callback;
@end example

This function pointer type is meant to match the one of the C Language
Standard function @cfunc{free}.
@end deftp


@deftypefun {void *} hoedown_malloc (size_t @var{size})
Wrapper for the C Language Standard @cfunc{malloc}.  If memory
allocation fails: abort the process by calling @cfunc{abort}.
@end deftypefun


@deftypefun {void *} hoedown_calloc (size_t @var{nmemb}, size_t @var{size})
Wrapper for the C Language Standard @cfunc{calloc}.  If memory
allocation fails: abort the process by calling @cfunc{abort}.
@end deftypefun


@deftypefun {void *} hoedown_realloc (void * @var{ptr}, size_t @var{size})
Wrapper for the C Language Standard @cfunc{realloc}.  If memory
reallocation fails: abort the process by calling @cfunc{abort}.
@end deftypefun


@c page
@node buffers struct
@section Data buffer structure


The definitions of the buffers @api{} are in the header file
@file{hoedown/buffer.h}.


@deftp {Struct Typedef} hoedown_buffer
Type of structures representing data buffers.  Instances of this type
must be initialised by @cfunc{hoedown_buffer_init} and finalised by
@cfunc{hoedown_buffer_uninit}.

Basic allocation, initialisation and finalisation can be performed as:

@example
hoedown_buffer          B;

hoedown_buffer_init(&B, 1, realloc, free, free);
hoedown_buffer_uninit(&B);
@end example

@noindent
or as:

@example
hoedown_buffer *        B;

B = hoedown_buffer_new(1);
hoedown_buffer_free(B);
@end example

Public fields in the data structure:

@table @code
@item size
The number of octets used in the internal data area.  It is the length
in octets of the contained data.
@end table
@end deftp


@deftypefun void hoedown_buffer_init (hoedown_buffer * @var{buffer}, size_t @var{reallocation-unit}, hoedown_realloc_callback @var{data_realloc}, hoedown_free_callback @var{data_free}, hoedown_free_callback @var{buffer_free})
Initialise a buffer with custom memory allocators.

@var{buffer} must be a pointer referencing an already allocated data
structure.  When the internal data area is reallocated to make it
bigger: @var{reallocation-unit} is the minimum increase in the area
size, measured in number of bytes.

@var{data_realloc} must reference a function used to allocate and/or
reallocate a memory block.  @var{data_free} must reference a function
used to release the data area of the buffer.  @var{buffer_free} must
reference a function used to release the @objtype{hoedown_buffer}
structure itself.
@end deftypefun


@deftypefun void hoedown_buffer_uninit (hoedown_buffer * @var{buf})
Finalise the given buffer structure.  Memory allocated for the internal
data area is released using the registered @var{data_free} function.
The memory block referenced by @var{buf} is @strong{not} released.
@end deftypefun


@deftypefun {hoedown_buffer *} hoedown_buffer_new (size_t @var{reallocation-unit})
Convenience function that allocates a new @objtype{hoedown_buffer}
structure and initialises it with default memory handlers; internally it
makes use of @cfunc{hoedown_buffer_init}.  Return a pointer to the newly
allocated structure.

The structure memory block is allocated with the C Language Standard
@cfunc{malloc}.  @cfunc{hoedown_realloc} is registered as
@var{data_realloc} function.  The C Language Standard @cfunc{free} is
registered as both @var{data_free} and @var{buffer_free} function.
@end deftypefun


@deftypefun void hoedown_buffer_free (hoedown_buffer * @var{buf})
Convenience function that finalises and releases the given buffer
structure; internally it is similar to @cfunc{hoedown_buffer_uninit}.
Release both the data area memory and the structure memory using the
registered memory handlers.
@end deftypefun


@deftypefun void hoedown_buffer_reset (hoedown_buffer * @var{buf})
Reset to empty the given buffer structure.  Release the internal data
area using the registered memory handlers.
@end deftypefun


@deftypefun void hoedown_buffer_grow (hoedown_buffer * @var{buf}, size_t @var{neosz})
Increase the allocated data area size to the given value.  Memory for
the data area is allocated and reallocated with the registered memory
handlers.

@example
hoedown_buffer              B;
hoedown_buffer_init(&B, 1, realloc, free, free);
@{
  hoedown_buffer_grow(&B, 4096);
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun

@c page
@node buffers append
@section Appending data to buffers


The definitions of the buffers @api{} are in the header file
@file{hoedown/buffer.h}.


@deftypefun void hoedown_buffer_put (hoedown_buffer * @var{buf}, const uint8_t * @var{data}, size_t @var{size})
Append raw data to a buffer.  The internal data area is resized as
needed and octets referenced by @var{data} are copied into it.

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_put(&B, (const uint8_t*)str, strlen(str));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun void hoedown_buffer_puts (hoedown_buffer * @var{buf}, const char * @var{str})
Append a NUL--terminated string to a buffer.

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str);
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefn {Preprocessor Macro} void HOEDOWN_BUFPUTSL (hoedown_buffer * @var{buf}, const char * @var{str})
Optimized @cfunc{hoedown_buffer_put} of a string literal.  It is meant
to be used when @var{str} references a literal string, as in:

@example
hoedown_buffer              B;
static const char *         str  = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  HOEDOWN_BUFPUTSL(&B, "Hello ");
  HOEDOWN_BUFPUTSL(&B, "World!");
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefn


@deftypefun void hoedown_buffer_putc (hoedown_buffer * @var{buf}, uint8_t @var{c})
Append a single char to a buffer.

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  for (int i=0; i<strlen(str); ++i) @{
    hoedown_buffer_putc(&B, str[i]);
  @}
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun int hoedown_buffer_putf (hoedown_buffer * @var{buf}, FILE * @var{file})
Read from a file and append to a buffer, until EOF or error.

@example
hoedown_buffer              B;
FILE *                      M;
char                        str[32];
hoedown_buffer_init(&B, 1024, realloc, free, free);
M = fopen("file.ext", "r");
@{
  hoedown_buffer_putf(&B, M);
@}
fclose(M);
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun void hoedown_buffer_put_utf8 (hoedown_buffer * @var{buf}, unsigned int @var{codepoint})
Put a Unicode character encoded as @utf{}-8.

@example
hoedown_buffer              B;
uint32_t                    cp    = 0x10FFFF;
uint8_t                     buf[] = @{
  244, 143, 191, 191
@};
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_put_utf8(&B, cp);
  assert(0 == memcmp(buf, B.data, B.size));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun

@c page
@node buffers set
@section Setting data in buffers


The definitions of the buffers @api{} are in the header file
@file{hoedown/buffer.h}.


@deftypefun void hoedown_buffer_set (hoedown_buffer * @var{buf}, const uint8_t * @var{data}, size_t @var{size})
Replace the buffer's contents with raw data.

@example
hoedown_buffer              B;
static const char *         str1 = "Hello World!";
static const char *         str2 = "Ciao Mondo!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_put(&B, (const uint8_t*)str1, strlen(str1));
  hoedown_buffer_set(&B, (const uint8_t*)str2, strlen(str2));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun void hoedown_buffer_sets (hoedown_buffer * @var{buf}, const char * @var{str})
Replace the buffer's contents with a NUL-terminated string.

@example
hoedown_buffer              B;
static const char *         str1 = "Hello World!";
static const char *         str2 = "Ciao Mondo!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str1);
  assert(0 == memcmp(str1, B.data, B.size));
  hoedown_buffer_sets(&B, str2);
  assert(0 == memcmp(str2, B.data, B.size));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefn {Preprocessor Macro} void HOEDOWN_BUFSETSL (hoedown_buffer * @var{buf}, const char * @var{str})
Optimized @cfunc{hoedown_buffer_sets} of a string literal.  It is meant
to be used when @var{str} references a literal string, as in:

@example
hoedown_buffer              B;
static const char *         str1 = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str1);
  HOEDOWN_BUFSETSL(&B, "Ciao Mondo!");
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefn

@c page
@node buffers compar
@section Comparing data in buffers


The definitions of the buffers @api{} are in the header file
@file{hoedown/buffer.h}.


@deftypefun int hoedown_buffer_eq (const hoedown_buffer * @var{buf}, const uint8_t * @var{data}, size_t @var{size})
Compare a buffer's data with other data for equality: return true
(non--zero) if the octets are equal, return false (zero) otherwise.

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str);
  assert(0 != hoedown_buffer_eq(&B,
                (const uint8_t*)str, strlen(str)));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun int hoedown_buffer_eqs (const hoedown_buffer * @var{buf}, const char * @var{str})
Compare a buffer's data with a NUL--terminated string for equality:
return true (non--zero) if the octets are equal, return false (zero)
otherwise.

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str);
  assert(0 != hoedown_buffer_eqs(&B, str));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefn {Preprocessor Macro} int HOEDOWN_BUFEQSL (hoedown_buffer * @var{buf}, const char * @var{str})
Optimized @cfunc{hoedown_buffer_eqs} of a string literal.  It is meant
to be used when @var{str} references a literal string, as in:

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str);
  assert(0 != HOEDOWN_BUFEQSL(&B, "Hello World!"));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefn


@deftypefun int hoedown_buffer_prefix (const hoedown_buffer * @var{buf}, const char * @var{prefix})
Compare the beginning of a buffer with a string: return zero if the
octets are equal; return greater than zero if an octet in @var{buf} is
found to be greater than the octet in @var{prefix}; return less than
zero if an octet in @var{buf} is found to be less than the octet in
@var{prefix}.

@example
hoedown_buffer              B;
static const char *         str1 = "Hello World!";
static const char *         str2 = "Hello";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str1);
  assert(0 == hoedown_buffer_prefix(&B, str2));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun

@c page
@node buffers misc
@section Miscellaneous functions


The definitions of the buffers @api{} are in the header file
@file{hoedown/buffer.h}.


@deftypefun void hoedown_buffer_slurp (hoedown_buffer * @var{buf}, size_t @var{size})
Remove a given number of bytes from the head of the buffer.

@example
hoedown_buffer              B;
static const char *         str = "Hello World!";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_puts(&B, str);
  hoedown_buffer_slurp(&B, strlen("Hello "));
  assert(0 != hoedown_buffer_eqs(&B, "World!"));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun {const char *} hoedown_buffer_cstr (hoedown_buffer * @var{buf})
Mutate the internal data area so that it valid as NUL-terminated C
string.  Return a pointer to the data area.
@end deftypefun


@deftypefun void hoedown_buffer_printf (hoedown_buffer * @var{buf}, const char * @var{fmt}, ...)
Formatted printing to a buffer.

@example
hoedown_buffer              B;
static const char *         str1 = "Hello";
static const char *         str2 = "World";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_buffer_printf(&B, "%s %s!", str1, str2);
  assert(0 != hoedown_buffer_eqs(&B, "Hello World!"));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun

@c page
@node stacks
@chapter Stack containers


@menu
* stacks struct::               Stack structures.
* stacks ops::                  Operations on stack structures.
@end menu

@c page
@node stacks struct
@section Stack structures


The definitions of the stacks @api{} are in the header file
@file{hoedown/stack.h}.


@deftp {Struct Typedef} hoedown_stack
Type of structures representing stacks of pointers.  Instances of this
type must be initialised by @cfunc{hoedown_stack_init} and finalised by
@cfunc{hoedown_stack_uninit}.

Basic allocation, initialisation and finalisation can be performed as:

@example
hoedown_stack          B;

hoedown_stack_init(&B, 123);
hoedown_stack_uninit(&B);
@end example

The data area of stack structures is allocated and reallocated with
@cfunc{hoedown_realloc} and released with C Language Standard
@cfunc{free}.
@end deftp


@deftypefun void hoedown_stack_init (hoedown_stack * @var{st}, size_t @var{initial_size})
Initialize an already allocated stack structures.
@end deftypefun


@deftypefun void hoedown_stack_uninit (hoedown_stack * @var{st})
Free internal data of the stack.
@end deftypefun


@deftypefun void hoedown_stack_grow (hoedown_stack * @var{st}, size_t @var{neosz})
Increase the allocated size to the given value.
@end deftypefun

@c page
@node stacks ops
@section Operations on stack structures


The definitions of the stacks @api{} are in the header file
@file{hoedown/stack.h}.


@deftypefun void hoedown_stack_push (hoedown_stack * @var{st}, void * @var{item})
Push an item to the top of the stack.
@end deftypefun


@deftypefun {void *} hoedown_stack_pop (hoedown_stack * @var{st})
Retrieve and remove the item at the top of the stack.  If the stack is
empty: return @cnull{}.
@end deftypefun


@deftypefun {void *} hoedown_stack_top (const hoedown_stack * @var{st})
Retrieve the item at the top of the stack.  If the stack is empty:
return @cnull{}.
@end deftypefun

@c page
@node escape
@chapter Escaping text elements


The definitions of the escaping @api{} are in the header file
@file{hoedown/escape.h}.


@deftypefun void hoedown_escape_href (hoedown_buffer * @var{ob}, const uint8_t * @var{data}, size_t @var{size})
Escape (part of) a @acronym{URL} inside @acronym{HTML}.  Escape all the
characters in the @var{data} memory block that cannot appear in a
@acronym{URL}; append the result to the buffer @var{ob}.

@example
hoedown_buffer      B;
const char *        str1 = "Father & Son";
const char *        str2 = "Father%20&amp;%20Son";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_escape_href(&B, (const uint8_t *)str1, strlen(str1));
  print_buffer(&B);
  assert(0 != hoedown_buffer_eqs(&B, str2));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun


@deftypefun void hoedown_escape_html (hoedown_buffer * @var{ob}, const uint8_t * @var{data}, size_t @var{size}, int @var{secure})
Escape @acronym{HTML} text from @var{data} and write the result in the
buffer @var{ob}.

@example
hoedown_buffer      B;
const char *        str1 = "Father & Son";
const char *        str2 = "Father &amp; Son";
hoedown_buffer_init(&B, 1024, realloc, free, free);
@{
  hoedown_escape_html(&B, (const uint8_t *)str1, strlen(str1), 1);
  print_buffer(&B);
  assert(0 != hoedown_buffer_eqs(&B, str2));
@}
hoedown_buffer_uninit(&B);
@end example
@end deftypefun

@c page
@node autolink
@chapter Autolink helpers


The definitions of the autolink @api{} are in the header file
@file{hoedown/autolink.h}.


@deftp {Enum Typedef} hoedown_autolink_flags
Type of constants used to configure the behaviour of the autolink helper
functions.  The following constants are defined:

@table @code
@item HOEDOWN_AUTOLINK_SHORT_DOMAINS
@cindex @code{HOEDOWN_AUTOLINK_SHORT_DOMAINS}, enum constant
@cindex Enum constant @code{HOEDOWN_AUTOLINK_SHORT_DOMAINS}
@end table
@end deftp


@deftypefun int hoedown_autolink_is_safe (const uint8_t * @var{data}, size_t @var{size})
Verify that a @acronym{URL} has a safe protocol.  Assume @var{data}
references a memory block holding a string of @utf{}-8 encoded
characters.  Return true (non--zero) if the prefix of the string matches
one among:

@example
http://
https://
/
#
ftp://
mailto:
@end example

@noindent
case insensitively, and the first octet after the prefix represents an
alphanumeric character; otherwise return false (zero).
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun size_t hoedown_autolink__www (size_t * @var{rewind_p}, hoedown_buffer * @var{link},	uint8_t * @var{w_ptr}, size_t @var{input_offset}, size_t @var{input_len}, hoedown_autolink_flags @var{flags})
Find the limits of a WWW link in the input Markdown buffer.

This function assumes that:

@itemize
@item
The input text is stored in a memory block as array of octets in
@utf{}-8 encoding; the block is @var{input_len} octets wide.

@item
The pointer @var{w_ptr} references an octet in the input text at
@var{input_offset} octets from the beginning.

@item
The pointer @var{w_ptr} references an octet representing the character
@code{w} in @utf{}-8 encoding:

@example
'w' == w_ptr[0]
@end example

@item
If @var{input_offset} is not zero (that is: @var{w_ptr} is not at the
beginning of the input text): the octet @code{w_ptr[-1]} represents a
space or a punctuation character according to the C Standard Library
functions @cfunc{ispunct} and @cfunc{isspace}:

@example
ispunct(w_ptr[-1]) || isspace(w_ptr[-1])
@end example
@end itemize

This function scans the input text starting at @var{w_ptr} looking for a
sequence of octets representing, in @utf{}-8 encoding, a web link.  The
sequence must begin with the prefix @samp{www.} (of which
@code{w_ptr[0]} is the first @samp{w}) followed by a string of octets
representing:

@itemize
@item
Alphanumeric characters according to the C Standard Library function
@cfunc{isalnum}.

@item
Colon characters @samp{:}.

@item
Dot characters @samp{.}.

@item
Dash characters @samp{-}.
@end itemize

@noindent
the string after @samp{www.} must contain at least one dot or one colon
to be considered a valid web link.

If a valid web link is found:

@itemize
@item
The string representing the link is appended to the buffer referenced by
@var{link}, which must be already initialised.

@item
The number of octets to the left of @var{w_ptr} which are part of the
web link, is stored in the location referenced by @var{rewind_p}.  For
this function: this value is always @samp{0}, because @var{w_ptr}
references the first octet in the link.

@item
The return value is the number of octets in the web link.  This number
is the offset to add to @var{w_ptr} to move it to the end of the link in
the input text.
@end itemize

If a valid web link is @strong{not} found: the return value is zero.

@example
char *              input_text   = \
   "the URL is www.hoedown.org/index.html, got it?";
size_t              input_len    = strlen(input_text);
size_t              input_offset = strlen("the URL is ");

uint8_t *           w_ptr = (uint8_t*)(input_text+input_offset);

hoedown_buffer      link;
size_t              offset_delta;
size_t              rewind;

assert('w' == input_text[input_offset]);
assert('w' == w_ptr[0]);

hoedown_buffer_init(&link, 1024, realloc, free, free);
@{
  offset_delta = hoedown_autolink__www(&rewind, &link,
     w_ptr, input_offset, input_len, 0);
  assert(strlen("www.hoedown.org/index.html") == offset_delta);
  assert(0 == rewind);
  assert(hoedown_buffer_eqs(&link, "www.hoedown.org/index.html"));
  assert(0 == strcmp((char *)(w_ptr+offset_delta), ", got it?"));
@}
hoedown_buffer_uninit(&link);
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun size_t hoedown_autolink__email (size_t * @var{rewind_p}, hoedown_buffer * @var{link}, uint8_t * @var{at_ptr}, size_t @var{input_offset}, size_t @var{input_len}, hoedown_autolink_flags @var{flags})
Find the limits of an email address link in the input Markdown buffer.

This function assumes that:

@itemize
@item
The input text is stored in a memory block as array of octets in
@utf{}-8 encoding; the block is @var{input_len} octets wide.

@item
The pointer @var{at_ptr} references an octet in the input text at
@var{input_offset} octets from the beginning.

@item
The pointer @var{at_ptr} references an octet representing the character
@code{@@} in @utf{}-8 encoding:

@example
'@@' == at_ptr[0]
@end example

@item
If @var{input_offset} is not zero (that is: @var{at_ptr} is not at the
beginning of the input text): the octets before @var{at_ptr} represent
alphanumeric characters (according to the C Standard Library function
@cfunc{isalnum}) or characters in the set @samp{.+-_}.
@end itemize

This function scans the input text starting at @var{at_ptr}, both in the
left and right directions, looking for a sequence of octets
representing, in @utf{}-8 encoding, an email address.  The sequence must
begin, to the left of the @samp{@@} character, with a non--empty prefix
composed of:

@itemize
@item
Alphanumeric characters according to the C Standard Library function
@cfunc{isalnum}.

@item
Characters in the set @samp{.+-_}.
@end itemize

@noindent
the sequence must end, to the right of the @samp{@@} character, with a
non--empty suffix composed of:

@itemize
@item
Alphanumeric characters according to the C Standard Library function
@cfunc{isalnum}.

@item
Characters in the set @samp{.-_}.
@end itemize

@noindent
the suffix must represent a valid host name.

If a valid email address is found:

@itemize
@item
The string representing the link is appended to the buffer referenced by
@var{link}, which must be already initialised.

@item
The number of octets to the left of @var{at_ptr} which are part of the
address, is stored in the location referenced by @var{rewind_p}.

@item
The return value is the number of octets in the email address at the
right of the @var{at_ptr} pointer.  This number is the offset to add to
@var{at_ptr} to move it to the end of the address in the input text.
@end itemize

If a valid email address is @strong{not} found: the return value is
zero.

@example
char *              input_text   = \
  "the address is kate.beckinsale@@underworld.earth, got it?";
size_t              input_len    = strlen(input_text);
size_t              input_offset = \
  strlen("the address is kate.beckinsale");

uint8_t *           at_ptr = (uint8_t *)(input_text+input_offset);

hoedown_buffer      link;
size_t              offset_delta;
size_t              rewind;

assert('@@' == input_text[input_offset]);
assert('@@' == at_ptr[0]);

hoedown_buffer_init(&link, 1024, realloc, free, free);
@{
  offset_delta = hoedown_autolink__email(&rewind, &link,
     at_ptr, input_offset, input_len, 0);
  assert(strlen("@@underworld.earth") == offset_delta);
  assert(strlen("kate.beckinsale") == rewind);
  assert(hoedown_buffer_eqs(&link,
     "kate.beckinsale@@underworld.earth"));
  assert(rewind + offset_delta == link.size);
  assert(0 == strcmp((char *)(at_ptr+offset_delta), ", got it?"));
@}
hoedown_buffer_uninit(&link);
@end example
@end deftypefun

@c ------------------------------------------------------------------------

@deftypefun size_t hoedown_autolink__url (size_t * @var{rewind_p}, hoedown_buffer * @var{link},	uint8_t * @var{colon_ptr}, size_t @var{input_offset}, size_t @var{input_len}, hoedown_autolink_flags @var{flags})
Find the limits of a @acronym{URL} in the input Markdown buffer.

This function assumes that:

@itemize
@item
The input text is stored in a memory block as array of octets in
@utf{}-8 encoding; the block is @var{input_len} octets wide.

@item
The pointer @var{colon_ptr} references an octet in the input text at
@var{input_offset} octets from the beginning.

@item
The pointer @var{colon_ptr} references an octet representing the
character @code{:} in @utf{}-8 encoding:

@example
':' == colon_ptr[0]
@end example

@item
If @var{input_offset} is not zero (that is: @var{colon_ptr} is not at
the beginning of the input text): the octets to the left of
@var{colon_ptr} must represent alphabetic characters according to the C
Standard Library function @cfunc{isalpha}.
@end itemize

This function scans the input text starting at @var{colon_ptr}, both in
the left and right directions, looking for a sequence of octets
representing, in @utf{}-8 encoding, a @acronym{URL}.  The sequence must
begin, to the left of the colon character, with a non--empty prefix
composed by alphabetic characters, according to the C Standard Library
function @cfunc{isalpha}.  The sequence must end, to the right of the
colon character, with a non--empty suffix composed of:

@itemize
@item
A sequence of @math{2} slash characters @samp{/}.

@item
A valid domain name composed of:

@itemize -
@item
Alphanumeric characters according to the C Standard Library function
@cfunc{isalnum}.

@item
Colon characters @samp{:}.

@item
Dot characters @samp{.}.

@item
Dash characters @samp{-}.
@end itemize
@end itemize

If a valid @acronym{URL} is found:

@itemize
@item
The string representing the @acronym{URL} is appended to the buffer
referenced by @var{link}, which must be already initialised.

@item
The number of octets to the left of @var{colon_ptr} which are part of
the @acronym{URL}, is stored in the location referenced by
@var{rewind_p}.

@item
The return value is the number of octets in the @acronym{URL} to the
right of @var{colon_ptr}.  This number is the offset to add to
@var{colon_ptr} to move it to the end of the @acronym{URL} in the input
text.
@end itemize

If a valid @acronym{URL} is @strong{not} found: the return value is
zero.

@example
char *              input_text   = \
   "the URL is http://www.hoedown.org/index.html, got it?";
size_t              input_len    = strlen(input_text);
size_t              input_offset = strlen("the URL is http");

uint8_t *           colon_ptr = \
   (uint8_t *)(input_text+input_offset);

hoedown_buffer      link;
size_t              offset_delta;
size_t              rewind;

assert(':' == input_text[input_offset]);
assert(':' == colon_ptr[0]);

hoedown_buffer_init(&link, 1024, realloc, free, free);
@{
  offset_delta = hoedown_autolink__url(&rewind, &link,
     colon_ptr, input_offset, input_len, 0);
  assert(strlen("://www.hoedown.org/index.html") == offset_delta);
  assert(4 == rewind);
  assert(hoedown_buffer_eqs(&link,
     "http://www.hoedown.org/index.html"));
  assert(rewind + offset_delta == link.size);
  assert(0 == strcmp((char *)(colon_ptr+offset_delta),
                     ", got it?"));
@}
hoedown_buffer_uninit(&link);
@end example
@end deftypefun

@c page
@node references
@appendix Bibliography and references


The latest release of the repackaged @value{PACKAGE} can be downloaded
from:

@center @value{DOWNLOAD_URL}

@noindent
the original package development takes place at:

@center @value{ORIGINAL_URL}

@noindent
development of the repackaging takes place at:

@center @value{GITHUB_URL}

@noindent
and as backup at:

@center @value{BITBUCKET_URL}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

